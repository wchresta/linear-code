{-# LANGUAGE DataKinds, KindSignatures, ScopedTypeVariables,
    TypeOperators, TypeFamilies, GeneralizedNewtypeDeriving #-}
{-|
Module      : Math.Code.Linear
Description : Linear codes over arbitrary fields
Copyright   : (c) Wanja Chresta, 2018
License     : GPL-3
Maintainer  : wanja.hs@chrummibei.ch
Stability   : experimental
Portability : POSIX

Naive implementation of coding theory linear codes and error correcting codes
over arbitrary fields, including finite fields. Goes well with the 
"HaskellForMath" library and its finite field implementations in
@Math.Algebra.Field@. To use extension fields (fields of prime power, i.e. 
@F_{p^k}@ with @k>1@), use one of the exportet finite fields in 
@Math.Algebra.Field.Extension@ like 'F16' and its generator 'a16'.
-}
module Math.Code.Linear
    ( LinearCode (..)
    , Generator, CheckMatrix
    , codeFromA

    -- * Code-Vectors and codewords
    , CVector, cvector, check, codeword, isCodeword

    -- * Code transformers
    , dualCode

    -- * Special codes
    , trivialCode, hamming74
    , BinaryCode

    -- * Reexported matrix functions
    , matrix, zero, transpose

    -- * Reexported finite fields
    , FiniteField, ExtensionField, char, F2
    ) where

-- Linear codes from mathematical coding theory, including error correcting
-- codes
import Prelude hiding (CVector)

import Data.Matrix (Matrix, matrix, transpose, (<|>), identity, zero, fromList)
import Math.Algebra.Field.Base (FiniteField, eltsFq, basisFq, F2, char)
import Math.Algebra.Field.Extension (ExtensionField)

import GHC.TypeLits (Nat, KnownNat, natVal, type (<=), type (-))
import Data.Proxy (Proxy (..))
import Data.Monoid ((<>))

-- | A Generator is the generator matrix of a linear code, not necessarily
--   in standard form.
type Generator (n :: Nat) (k :: Nat) (f :: *) = Matrix f
type CheckMatrix (n :: Nat) (k :: Nat) (f :: *) = Matrix f

-- | A [n,k]-Linear code over the field f. The code parameters f,n and k
--   are carried on the type level.
--   A linear code is a subspace C of f generated by the generator matrix.
data LinearCode (n :: Nat) (k :: Nat) (f :: *)
    = LinearCode { generatorMatrix :: Generator n k f
                 , standardFormGenerator :: Generator n k f
                 , checkMatrix :: CheckMatrix n k f
                 }

instance (Eq f, Num f) => Eq (LinearCode n k f) where
    c == d = standardFormGenerator c == standardFormGenerator d

instance (KnownNat n, KnownNat k)
  => Show (LinearCode n k f) where
        show LinearCode{} =
            '[':show n'<>","<>show k'<>"]_"<>show c'<>"-Code"
            where n' = fromInteger $ natVal (Proxy :: Proxy n)
                  k' = fromInteger $ natVal (Proxy :: Proxy k)
                  c' = char (Proxy :: Proxy f)


-- | Convenience function to extract the length @n@ from the type level
codeLength :: forall n k f. KnownNat n => LinearCode n k f -> Int
codeLength _ = fromInteger $ natVal (Proxy :: Proxy n)

-- | Convenience function to extract the rank @k@ from the type level.
rank :: forall n k f. KnownNat k => LinearCode n k f -> Int
rank _ = fromInteger $ natVal (Proxy :: Proxy k)

-- | Generate a linear [n,k]_q-Code over the field a with the generator in
--   standard form (I|A), where the given function generates the kÃ—(n-k)-matrix
--   A.
codeFromA :: forall n k f. (Num f, KnownNat n, KnownNat k)
          => ((Int, Int) -> f) -> LinearCode n k f
codeFromA aij =
    let n' = fromInteger $ natVal (Proxy :: Proxy n)
        k' = fromInteger $ natVal (Proxy :: Proxy k)
        a = matrix k' (n'-k') aij
        g = identity k' <|> a
     in LinearCode
         { generatorMatrix = g
         , standardFormGenerator = g
         , checkMatrix = -transpose a <|> identity (n'-k')
         }


-- | A CodeCVector is a vector in the subspace C generated by the generator
--   of a linear code.
newtype CVector (n :: Nat) (f :: *) = CVector (Matrix f)
    deriving (Eq, Show, Functor)

instance (Num f, KnownNat n) => Monoid (CVector n f) where
    mempty = CVector $ zero 1 n'
        where n' = fromInteger $ natVal (Proxy :: Proxy n)
    mappend (CVector x) (CVector y) = CVector $ x + y

-- | Convenience function to create a word from a list
--   Will return Nothing if the list is not of the right size
--   A word in a linear code is a vector in the code field and of size n
--   but not necessarily a valid codeword. Use 'isCVector' to check
--   if a word is a codeword.
cvector :: KnownNat n => LinearCode n k f -> [f] -> Maybe (CVector n f)
cvector code cs =
    let n = codeLength code
     in if length cs == n
           then Just . CVector $ fromList 1 n cs
           else Nothing

codeword :: (Num f, KnownNat k) => LinearCode n k f -> [f] -> Maybe (CVector n f)
codeword code vs =
    let k = rank code
     in if length vs == k
           then Just . CVector $ fromList 1 k vs * generatorMatrix code
           else Nothing

-- | Check multiplies the given codeword with the check matrix of the linear
--   code. If the result is the zero matrix, the given candidate is a valid
--   code word for the given code.
check :: Num f => LinearCode n k f -> CVector n f -> Matrix f
check code (CVector c) = checkMatrix code * transpose c

-- | Checks if the given candidate code word is a valid code word for the
--   given linear code. If not, the party check failed.
isCodeword :: forall n k f. (Eq f, Num f, KnownNat n, KnownNat k) =>
    LinearCode n k f -> CVector n f -> Bool
isCodeword code c =
    let n' = fromInteger $ natVal (Proxy :: Proxy n)
        k' = fromInteger $ natVal (Proxy :: Proxy k)
     in check code c == zero (n'-k') 1


-- * Code transformers

-- |The dual code is the code generated by the check matrix
dualCode :: (KnownNat n, KnownNat k) => LinearCode n k f -> LinearCode n (n-k) f
dualCode (LinearCode _ g h) = LinearCode h h g

-- | A binary code is a linear code over the field GF(2)
type BinaryCode n k = LinearCode n k F2

-- | The trivial code is the identity code where the parity bits are all zero.
trivialCode :: (Num f, KnownNat n, KnownNat k) => LinearCode n k f
trivialCode = codeFromA (const 0)

-- TODO: randomCode

-- | The /Hamming(7,4)/-code.
hamming74 :: LinearCode 7 4 F2
hamming74 = codeFromA (\(i,j) -> a !! (j-1) !! (i-1)) -- k,n-k = 4,3
    where a = [[0,1,1,1],[1,0,1,1],[1,1,0,1]]

