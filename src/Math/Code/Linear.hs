{-# LANGUAGE DataKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}
{-|
Module      : Math.Code.Linear
Description : Linear codes over arbitrary fields
Copyright   : (c) Wanja Chresta, 2018
License     : GPL-3
Maintainer  : wanja.hs@chrummibei.ch
Stability   : experimental
Portability : POSIX

Naive implementation of coding theory linear codes and error correcting codes
over arbitrary fields, including finite fields. Goes well with the
@HaskellForMath@ library and its finite field implementations in
@Math.Algebra.Field@. To use extension fields (fields of prime power, i.e.
@F_{p^k}@ with @k>1@), use one of the exported finite fields in
@Math.Algebra.Field.Extension@ like 'F16' and its generator 'a16'.
-}
module Math.Code.Linear
    ( LinearCode (..)
    , Generator, CheckMatrix
    , codeFromA

    -- * Code-Vectors and codewords
    , Vector, syndrome, encode, isCodeword, hasError

    -- * Code transformers
    , dualCode

    -- * Special codes
    , trivialCode, simplex, hamming, randomCode
    , BinaryCode

    -- * Reexported matrix functions
    , matrix, zero, transpose, fromList, fromLists

    -- * Reexported finite fields
    , FiniteField, ExtensionField, char, F2
    ) where

-- Linear codes from mathematical coding theory, including error correcting
-- codes
import Prelude hiding (CVector)
import GHC.TypeLits
        ( Nat, KnownNat, natVal
        , type (<=), type (+), type (-), type (^)
        )
import Data.Proxy (Proxy (..))
import Data.Monoid ((<>))
import Data.Either (fromRight)
import System.Random (Random, random, randomR)
import Control.Monad.Random.Class (MonadRandom, getRandoms)

import Data.Matrix.Safe
    ( Matrix, matrix, transpose, (<|>), (.*)
    , identity, zero, fromList, fromLists, Vector, rref
    )
import Math.Common.IntegerAsType (IntegerAsType, value)
import Math.Algebra.Field.Base
        (FiniteField, eltsFq, basisFq, Fp(Fp), char
        , F2, F3, F5, F7, F11, F13, F17, F19, F23, F29, F31, F37, F41, F43
        , F47, F53, F59, F61, F67, F71, F73, F79, F83, F89, F97
        )
import Math.Algebra.Field.Static (Size, Characteristic, PolyDegree)
import Math.Algebra.Field.Extension (ExtensionField(Ext), x, embed, pvalue)
import Math.Algebra.Field.Random -- import Random instances for Fields


-- | A Generator is the generator matrix of a linear code, not necessarily
--   in standard form.
type Generator (n :: Nat) (k :: Nat) = Matrix k n
type CheckMatrix (n :: Nat) (k :: Nat) = Matrix (n-k) n

-- | A [n,k]-Linear code over the field f. The code parameters f,n and k
--   are carried on the type level.
--   A linear code is a subspace C of f generated by the generator matrix.
data LinearCode (n :: Nat) (k :: Nat) (f :: *)
    = LinearCode { generatorMatrix :: Generator n k f
                 -- ^ Generator matrix, used for most of the operations
                 -- , standardFormGenerator :: Maybe (Generator n k f)
                 -- ^ (Lazy) standard form generator. Only used for few
                 --   code transformation operations.
                 , checkMatrix :: CheckMatrix n k f
                 -- ^ Check matrix which can be automatically calculated
                 --   from the standard form generator.
                 }

natToInt :: forall k. KnownNat k => Proxy k -> Int
natToInt = fromInteger . natVal

-- FIXME: This is wrong
instance forall n k f. (Eq f, Num f) => Eq (LinearCode n k f) where
    c == d = generatorMatrix c == generatorMatrix d

instance forall n k f. (KnownNat n, KnownNat k)
    => Show (LinearCode n k f) where
        show LinearCode{} =
            '[':show n<>","<>show k<>"]_"<>show c<>"-Code"
                where c = char (Proxy :: Proxy f)
                      n = natToInt @n Proxy
                      k = natToInt @k Proxy


-- | Uses Gaussian eleminiation via 'rref' from 'Data.Matrix.Safe' to
--   find the standard form of generators. Since @Data.Matrix@'s rref
--   could give an error, and generators should always be convertible
--   to standard forms, it's probably fine to ignore the error case.
--   This makes this unsafe. If you want a safe variant, use rref
--   and handle the 'Left' case.
unsafeStandardForm :: forall n k f.
    (Eq f, Fractional f, KnownNat n, KnownNat k, k <= n)
                   => Generator n k f -> Generator n k f
unsafeStandardForm = fromRight (error "rref failed") . rref


-- | Convenience function to extract the length @n@ from the type level
codeLength :: forall n k f. KnownNat n => LinearCode n k f -> Int
codeLength _ = natToInt @n Proxy

-- | Convenience function to extract the rank @k@ from the type level.
rank :: forall n k f. KnownNat k => LinearCode n k f -> Int
rank _ = natToInt @k Proxy

-- | The hamming weight of a Vector is an 'Int' between 0 and n
weight :: forall n f m. (Eq f, Num f, Functor m, Foldable m) => m f -> Int
weight = sum . fmap (\x -> if x==0 then 0 else 1)

-- | Generate a linear [n,k]_q-Code over the field a with the generator in
--   standard form (I|A), where the given function generates the k√ó(n-k)-matrix
--   A.
codeFromA :: forall k n f. (Num f, KnownNat n, KnownNat k, k <= n)
          => Matrix k (n-k) f
            -- ^ Elements of A where top-left is (1,1) and bottom right (k,n-k)
          -> LinearCode n k f
codeFromA a =
    let g = identity <|> a :: Generator n k f
     in LinearCode
         { generatorMatrix = g
         , checkMatrix = -transpose a <|> identity
         }

-- | Get the codeword generated by the given k-sized vector.
encode :: forall n k f. Num f => LinearCode n k f -> Vector k f -> Vector n f
encode code vs = vs .* generatorMatrix code


-- | Give the syndrome of a word for the given code. This is 0 if the word
--   is a valid code word.
syndrome :: forall n k f. Num f 
         => LinearCode n k f -> Vector n f -> Vector (n-k) f
syndrome c w = w .* transpose (checkMatrix c)

-- | Uses the exponential-time syndrome decoding algorithm for general codes.
{-
syndromeDecode :: forall n k f. Num f 
               => LinearCode n k f -> Vector n f -> Vector k f
syndromeDecode c w =
    let syn = syndrome c w
     in zero

decode = syndromeDecode
-}

-- | Check if the given candidate code word is a valid code word for the
--   given linear code. If not, the party check failed.
isCodeword :: forall n k f. (Eq f, Num f, KnownNat n, KnownNat k, k <= n)
           => LinearCode n k f -> Vector n f -> Bool
isCodeword c w = syndrome c w == zero


-- | Check if the given candidate code word has errors, i.e. if some element
--   changed during transmission. This is equivalent with @not@ 'isCodeword'
hasError :: forall n k f. (Eq f, Num f, KnownNat n, KnownNat k, k <= n)
         => LinearCode n k f -> Vector n f -> Bool
hasError g = not . isCodeword g

-- * Code transformers

-- |The dual code is the code generated by the check matrix
dualCode :: forall n k f. (Eq f, Fractional f, KnownNat n, KnownNat k, k <= n)
         => LinearCode n k f -> LinearCode n (n-k) f
dualCode (LinearCode g h) = LinearCode h g

-- | A binary code is a linear code over the field GF(2)
type BinaryCode n k = LinearCode n k F2

-- | The trivial code is the identity code where the parity bits are all zero.
trivialCode :: forall n k f. (Num f, KnownNat n, KnownNat k, k <= n)
            => LinearCode n k f
trivialCode = codeFromA (zero :: Matrix k (n-k) f)

-- | A random linear code
randomCode :: forall n k f m.
              (Random f, Num f, KnownNat n, KnownNat k, k <= n, MonadRandom m)
           => m (LinearCode n k f)
randomCode = do
    let n = natToInt @n Proxy
        k = natToInt @k Proxy
    randomElements <- fmap (take $ k*(n-k)) getRandoms
    let randomMatrix = fromList randomElements
    return $ codeFromA randomMatrix

simplex :: forall k p s.
    ( KnownNat s, KnownNat k , IntegerAsType p
    , 1 <= s^k, k <= s^k, 1+k <= s^k, Size (Fp p) ~ s)
        => LinearCode (s^k-1) k (Fp p)
simplex = codeFromA . transpose $ fromLists nonUnit
    where k = natToInt @k Proxy
          allVectors :: Size (Fp p) ~ s => [[Fp p]]
          allVectors = fmap reverse . tail $ iterate ([(0:),(1:)] <*>) [[]] !! k
          --nonUnit :: Size (Fp p) ~ s => [[Fp p]]
          nonUnit = filter ((>1) . weight) allVectors

-- | The /Hamming(7,4)/-code.
hamming :: (KnownNat m, 2 <= m, m <= 2^m, 1+m <= 2^m)
        => LinearCode (2^m-1) (2^m-m-1) F2
hamming = dualCode simplex




