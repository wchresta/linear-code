{-# LANGUAGE DataKinds, KindSignatures, ScopedTypeVariables
  , TypeOperators, TypeFamilies, GeneralizedNewtypeDeriving #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}
{-|
Module      : Math.Code.Linear
Description : Linear codes over arbitrary fields
Copyright   : (c) Wanja Chresta, 2018
License     : GPL-3
Maintainer  : wanja.hs@chrummibei.ch
Stability   : experimental
Portability : POSIX

Naive implementation of coding theory linear codes and error correcting codes
over arbitrary fields, including finite fields. Goes well with the
@HaskellForMath@ library and its finite field implementations in
@Math.Algebra.Field@. To use extension fields (fields of prime power, i.e.
@F_{p^k}@ with @k>1@), use one of the exported finite fields in
@Math.Algebra.Field.Extension@ like 'F16' and its generator 'a16'.
-}
module Math.Code.Linear
    ( LinearCode (..)
    , Generator, CheckMatrix
    , codeFromA

    -- * Code-Vectors and codewords
    , Vector, check, codeword, isCodeword

    -- * Code transformers
    , dualCode

    -- * Special codes
    , trivialCode, hamming74
    , BinaryCode

    -- * Reexported matrix functions
    , matrix, zero, transpose, fromList, fromLists

    -- * Reexported finite fields
    , FiniteField, ExtensionField, char, F2
    ) where

-- Linear codes from mathematical coding theory, including error correcting
-- codes
import Prelude hiding (CVector)

import Data.Matrix.Safe
    ( Matrix, matrix, transpose, (<|>), (.*)
    , identity, zero, fromList, fromLists, Vector
    )
import Math.Algebra.Field.Base (FiniteField, eltsFq, basisFq, F2, char)
import Math.Algebra.Field.Extension (ExtensionField)

import GHC.TypeLits (Nat, KnownNat, natVal, type (<=), type (+), type (-))
import Data.Proxy (Proxy (..))
import Data.Monoid ((<>))

-- | A Generator is the generator matrix of a linear code, not necessarily
--   in standard form.
type Generator (n :: Nat) (k :: Nat) = Matrix k n
type CheckMatrix (n :: Nat) (k :: Nat) = Matrix (n-k) n

-- | A [n,k]-Linear code over the field f. The code parameters f,n and k
--   are carried on the type level.
--   A linear code is a subspace C of f generated by the generator matrix.
data LinearCode (n :: Nat) (k :: Nat) (f :: *)
    = LinearCode { generatorMatrix :: Generator n k f
                 -- ^ Generator matrix, used for most of the operations
                 , standardFormGenerator :: Generator n k f
                 -- ^ (Lazy) standard form generator. Only used for few
                 --   code transformation operations.
                 , checkMatrix :: CheckMatrix n k f
                 -- ^ Check matrix which can be automatically calculated
                 --   from the standard form generator.
                 }

instance forall n k f. (Eq f, Num f) => Eq (LinearCode n k f) where
    c == d = standardFormGenerator c == standardFormGenerator d

instance forall n k f. (KnownNat n, KnownNat k)
    => Show (LinearCode n k f) where
        show LinearCode{} =
            '[':show n'<>","<>show k'<>"]_"<>show c'<>"-Code"
            where n' = fromInteger $ natVal (Proxy :: Proxy n)
                  k' = fromInteger $ natVal (Proxy :: Proxy k)
                  c' = char (Proxy :: Proxy f)


-- | Convenience function to extract the length @n@ from the type level
codeLength :: forall n k f. KnownNat n => LinearCode n k f -> Int
codeLength _ = fromInteger $ natVal (Proxy :: Proxy n)

-- | Convenience function to extract the rank @k@ from the type level.
rank :: forall n k f. KnownNat k => LinearCode n k f -> Int
rank _ = fromInteger $ natVal (Proxy :: Proxy k)

-- | Generate a linear [n,k]_q-Code over the field a with the generator in
--   standard form (I|A), where the given function generates the k√ó(n-k)-matrix
--   A.
codeFromA :: forall k n f. (Num f, KnownNat n, KnownNat k, k <= n)
          => Matrix k (n-k) f
            -- ^ Elements of A where top-left is (1,1) and bottom right (k,n-k)
          -> LinearCode n k f
codeFromA a =
    let g = identity <|> a :: Generator n k f
     in LinearCode
         { generatorMatrix = g
         , standardFormGenerator = g
         , checkMatrix = -transpose a <|> identity
         }

-- | Get the codeword generated by the given k-sized vector.
codeword :: forall n k f. Num f => LinearCode n k f -> Vector k f -> Vector n f
codeword code vs = vs .* generatorMatrix code

-- | Check multiplies the given codeword with the check matrix of the linear
--   code. If the result is the zero matrix, the given candidate is a valid
--   code word for the given code.
check :: forall n k f. (Num f, k <= n) 
      => LinearCode n k f -> Vector n f -> Matrix (n-k) 1 f
check c v = checkMatrix c .* transpose v

-- | Checks if the given candidate code word is a valid code word for the
--   given linear code. If not, the party check failed.
isCodeword :: forall n k f. (Eq f, Num f, KnownNat n, KnownNat k, k <= n)
           => LinearCode n k f -> Vector n f -> Bool
isCodeword code c = check code c == zero


-- * Code transformers

-- |The dual code is the code generated by the check matrix
dualCode :: forall n k f. (KnownNat n, KnownNat k, k <= n) 
         => LinearCode n k f -> LinearCode n (n-k) f
dualCode (LinearCode _ g h) = LinearCode h h g

-- | A binary code is a linear code over the field GF(2)
type BinaryCode n k = LinearCode n k F2

-- | The trivial code is the identity code where the parity bits are all zero.
trivialCode :: forall n k f. (Num f, KnownNat n, KnownNat k, k <= n) 
            => LinearCode n k f
trivialCode = codeFromA (zero :: Matrix k (n-k) f)

-- TODO: randomCode

-- | The /Hamming(7,4)/-code.
hamming74 :: LinearCode 7 4 F2
hamming74 = codeFromA $ fromLists [[0,1,1],[1,0,1],[1,1,0],[1,1,1]]

