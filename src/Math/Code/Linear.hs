{-# LANGUAGE DataKinds, KindSignatures, ScopedTypeVariables, TypeApplications
  , TypeOperators, TypeFamilies, GeneralizedNewtypeDeriving #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}
{-|
Module      : Math.Code.Linear
Description : Linear codes over arbitrary fields
Copyright   : (c) Wanja Chresta, 2018
License     : GPL-3
Maintainer  : wanja.hs@chrummibei.ch
Stability   : experimental
Portability : POSIX

Naive implementation of coding theory linear codes and error correcting codes
over arbitrary fields, including finite fields. Goes well with the
@HaskellForMath@ library and its finite field implementations in
@Math.Algebra.Field@. To use extension fields (fields of prime power, i.e.
@F_{p^k}@ with @k>1@), use one of the exported finite fields in
@Math.Algebra.Field.Extension@ like 'F16' and its generator 'a16'.
-}
module Math.Code.Linear
    ( LinearCode (..)
    , Generator, CheckMatrix
    , codeFromA

    -- * Code-Vectors and codewords
    , Vector, check, codeword, isCodeword

    -- * Code transformers
    , dualCode

    -- * Special codes
    , trivialCode, simplex, hamming, randomCode
    , BinaryCode

    -- * Reexported matrix functions
    , matrix, zero, transpose, fromList, fromLists

    -- * Reexported finite fields
    , FiniteField, ExtensionField, char, F2
    ) where

-- Linear codes from mathematical coding theory, including error correcting
-- codes
import Prelude hiding (CVector)
import GHC.TypeLits 
        ( Nat, KnownNat, natVal
        , type (<=), type (+), type (-), type (^)
        )
import Data.Proxy (Proxy (..))
import Data.Monoid ((<>))
import Data.Either (fromRight)
import System.Random (Random, random, randomR)
import Control.Monad.Random.Class (MonadRandom, getRandoms)

import Data.Matrix.Safe
    ( Matrix, matrix, transpose, (<|>), (.*)
    , identity, zero, fromList, fromLists, Vector, rref
    )
import Math.Common.IntegerAsType (IntegerAsType, value)
import Math.Algebra.Field.Base 
        (FiniteField, eltsFq, basisFq, Fp(Fp), char
        , F2, F3, F5, F7, F11, F13, F17, F19, F23, F29, F31, F37, F41, F43
        , F47, F53, F59, F61, F67, F71, F73, F79, F83, F89, F97
        )
import Math.Algebra.Field.Extension (ExtensionField)


-- | A Generator is the generator matrix of a linear code, not necessarily
--   in standard form.
type Generator (n :: Nat) (k :: Nat) = Matrix k n
type CheckMatrix (n :: Nat) (k :: Nat) = Matrix (n-k) n

-- | A [n,k]-Linear code over the field f. The code parameters f,n and k
--   are carried on the type level.
--   A linear code is a subspace C of f generated by the generator matrix.
data LinearCode (n :: Nat) (k :: Nat) (f :: *)
    = LinearCode { generatorMatrix :: Generator n k f
                 -- ^ Generator matrix, used for most of the operations
                 , standardFormGenerator :: Generator n k f
                 -- ^ (Lazy) standard form generator. Only used for few
                 --   code transformation operations.
                 , checkMatrix :: CheckMatrix n k f
                 -- ^ Check matrix which can be automatically calculated
                 --   from the standard form generator.
                 }

natToInt :: forall k. KnownNat k => Proxy k -> Int
natToInt = fromInteger . natVal

instance forall n k f. (Eq f, Num f) => Eq (LinearCode n k f) where
    c == d = standardFormGenerator c == standardFormGenerator d

instance forall n k f. (KnownNat n, KnownNat k)
    => Show (LinearCode n k f) where
        show LinearCode{} =
            '[':show n<>","<>show k<>"]_"<>show c<>"-Code"
                where c = char (Proxy :: Proxy f)
                      n = natToInt @n Proxy
                      k = natToInt @k Proxy


-- | Uses Gaussian eleminiation via 'rref' from 'Data.Matrix.Safe' to
--   find the standard form of generators. Since @Data.Matrix@'s rref
--   could give an error, and generators should always be convertible
--   to standard forms, it's probably fine to ignore the error case.
--   This makes this unsafe. If you want a safe variant, use rref
--   and handle the 'Left' case.
unsafeStandardForm :: forall n k f. 
    (Eq f, Fractional f, KnownNat n, KnownNat k, k <= n)
                   => Generator n k f -> Generator n k f
unsafeStandardForm = fromRight (error "rref failed") . rref


-- | Convenience function to extract the length @n@ from the type level
codeLength :: forall n k f. KnownNat n => LinearCode n k f -> Int
codeLength _ = natToInt @n Proxy

-- | Convenience function to extract the rank @k@ from the type level.
rank :: forall n k f. KnownNat k => LinearCode n k f -> Int
rank _ = natToInt @k Proxy

-- | The hamming weight of a Vector is an 'Int' between 0 and n
weight :: forall n f m. (Eq f, Num f, Functor m, Foldable m) => m f -> Int
weight = sum . fmap (\x -> if x==0 then 0 else 1)

-- | Generate a linear [n,k]_q-Code over the field a with the generator in
--   standard form (I|A), where the given function generates the k√ó(n-k)-matrix
--   A.
codeFromA :: forall k n f. (Num f, KnownNat n, KnownNat k, k <= n)
          => Matrix k (n-k) f
            -- ^ Elements of A where top-left is (1,1) and bottom right (k,n-k)
          -> LinearCode n k f
codeFromA a =
    let g = identity <|> a :: Generator n k f
     in LinearCode
         { generatorMatrix = g
         , standardFormGenerator = g
         , checkMatrix = -transpose a <|> identity
         }

-- | Get the codeword generated by the given k-sized vector.
codeword :: forall n k f. Num f => LinearCode n k f -> Vector k f -> Vector n f
codeword code vs = vs .* generatorMatrix code

-- | Check multiplies the given codeword with the check matrix of the linear
--   code. If the result is the zero matrix, the given candidate is a valid
--   code word for the given code.
check :: forall n k f. (Num f, k <= n)
      => LinearCode n k f -> Vector n f -> Matrix (n-k) 1 f
check c v = checkMatrix c .* transpose v

-- | Checks if the given candidate code word is a valid code word for the
--   given linear code. If not, the party check failed.
isCodeword :: forall n k f. (Eq f, Num f, KnownNat n, KnownNat k, k <= n)
           => LinearCode n k f -> Vector n f -> Bool
isCodeword code c = check code c == zero


-- * Code transformers

-- |The dual code is the code generated by the check matrix
dualCode :: forall n k f. (Eq f, Fractional f, KnownNat n, KnownNat k, k <= n)
         => LinearCode n k f -> LinearCode n (n-k) f
dualCode (LinearCode _ g h) = LinearCode h (unsafeStandardForm h) g

-- | A binary code is a linear code over the field GF(2)
type BinaryCode n k = LinearCode n k F2

-- | The trivial code is the identity code where the parity bits are all zero.
trivialCode :: forall n k f. (Num f, KnownNat n, KnownNat k, k <= n)
            => LinearCode n k f
trivialCode = codeFromA (zero :: Matrix k (n-k) f)

-- Add Random instance for Fp so that we can create random codes
instance forall p. IntegerAsType p => Random (Fp p) where
    randomR (Fp l, Fp h) g = case randomR (l,h) g of
                                 (a,g') -> (Fp a,g')
    random g = case randomR (0,p-1) g of
                   (a,g') -> (Fp a,g')
        where p = value (undefined :: p)
-- TODO: Add random Instance for Extensions

randomCode :: forall n k f m.
              (Random f, Num f, KnownNat n, KnownNat k, k <= n, MonadRandom m)
           => m (LinearCode n k f)
randomCode = do
    let n = natToInt @n Proxy
        k = natToInt @k Proxy
    randomElements <- fmap (take $ k*(n-k)) getRandoms
    let randomMatrix = fromList randomElements
    return $ codeFromA randomMatrix

simplex :: forall k p s. 
    ( KnownNat s, KnownNat k , IntegerAsType p
    , 1 <= s^k, k <= s^k, 1+k <= s^k, Size (Fp p) ~ s) 
        => LinearCode (s^k-1) k (Fp p)
simplex = codeFromA . transpose $ fromLists nonUnit
    where k = natToInt @k Proxy
          allVectors :: Size (Fp p) ~ s => [[Fp p]]
          allVectors = fmap reverse . tail $ iterate ([(0:),(1:)] <*>) [[]] !! k
          nonUnit :: Size (Fp p) ~ s => [[Fp p]]
          nonUnit = filter ((>1) . weight) allVectors

-- | The /Hamming(7,4)/-code.
hamming :: (KnownNat m, 2 <= m, m <= 2^m, 1+m <= 2^m) 
        => LinearCode (2^m-1) (2^m-m-1) F2
hamming = dualCode simplex

-- Type family magic; converting from IntegerAsType to KnownNat
type family Size t :: Nat where
    Size F2 = 2
    Size F3 = 3
    Size F5 = 5
    Size F7 = 7
    Size F11 = 11
    Size F13 = 13
    Size F17 = 17
    Size F19 = 19
    Size F23 = 23
    Size F29 = 29
    Size F31 = 31
    Size F37 = 37
    Size F41 = 41
    Size F43 = 43
    Size F47 = 47
    Size F53 = 53
    Size F59 = 59
    Size F61 = 61
    Size F67 = 67
    Size F71 = 71
    Size F73 = 73
    Size F79 = 79
    Size F83 = 83
    Size F89 = 89
    Size F97 = 97

