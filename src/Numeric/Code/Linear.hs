{-# LANGUAGE DataKinds, KindSignatures, ScopedTypeVariables,
    TypeOperators, TypeFamilies #-}
module Numeric.Code.Linear
    ( BinaryCode, BinaryGenerator
    , LinearCode (..)
    , GenPartA, Generator, CheckMatrix
    , codeFromA
    , trivialBinaryCode
    , Codeword, codeword, check, isCodeword

    -- Reexporting
    , matrix, zero, transpose
    , GF2
    ) where

-- Linear codes from mathematical coding theory, including error correcting
-- codes
import Numeric.Field.Finite (Field, characteristic, GFp (..), GF2, gfp, GF)
-- import Numeric.LinearAlgebra.Data (Matrix, matrix, tr', (|||), ident)
import Data.Matrix (Matrix, matrix, transpose, (<|>), identity, zero, fromList)

import GHC.TypeLits (Nat, KnownNat, natVal, type (<=))
import Data.Proxy (Proxy (..))
import Data.Monoid ((<>))

-- | A GenPartA is the non-identity part of a linear code generator in
--   standard form (I|A). It's a k×(n-k)-matrix
type GenPartA (f :: *) (n :: Nat) (k :: Nat) = Matrix f

-- | A Generator is the generator matrix of a linear code, not necessarily
--   in standard form.
type Generator (f :: *) (n :: Nat) (k :: Nat) = Matrix f
type CheckMatrix (f :: *) (n :: Nat) (k :: Nat) = Matrix f

-- | A [n,k]-Linear code over the field f. The code parameters f,n and k
--   are carried on the type level.
--   A linear code is a subspace C of f generated by the generator matrix.
data LinearCode (f :: *) (n :: Nat) (k :: Nat)
  = LinearCode { generatorMatrix :: Generator f n k
               , standardFormGenerator :: Generator f n k
               , checkMatrix :: CheckMatrix f n k
               }

-- | Convenience function to extract the length n from the type level
codeLength :: forall f n k. KnownNat n => LinearCode f n k -> Int
codeLength _ = fromInteger $ natVal (Proxy :: Proxy n)

instance (Eq f, Num f) => Eq (LinearCode f n k) where
    c == d = standardFormGenerator c == standardFormGenerator d

instance (KnownNat n, KnownNat k, Field f)
  => Show (LinearCode f n k) where
        show LinearCode{} =
            '[':show n'<>","<>show k'<>"]_"<>show c'<>"-Code"
            where n' = fromInteger $ natVal (Proxy :: Proxy n)
                  k' = fromInteger $ natVal (Proxy :: Proxy k)
                  c' = characteristic (Proxy :: Proxy f)

-- | A binary generator is a linear code generator matrix for field GF(2)
type BinaryGenerator n k = Generator GF2 n k
-- | A binary code is a linear code over the field GF(2)
type BinaryCode n k = LinearCode GF2 n k

-- | Generate a linear [n,k]_q-Code over the field a with the generator in
--   standard form (I|A), where the given function generates the k×(n-k)-matrix
--   A.
codeFromA :: forall a n k. (Num a, KnownNat n, KnownNat k)
    => ((Int, Int) -> a) -> LinearCode a n k
codeFromA aij =
    let n' = fromInteger $ natVal (Proxy :: Proxy n)
        k' = fromInteger $ natVal (Proxy :: Proxy k)
        a = matrix k' (n'-k') aij
        g = identity k' <|> a
     in LinearCode
         { generatorMatrix = g
         , standardFormGenerator = g
         , checkMatrix = -transpose a <|> identity (n'-k')
         }

-- | The trivial binary code is the identity code where the parity bits
--   are always zero.
trivialBinaryCode :: (KnownNat n, KnownNat k) => BinaryCode n k
trivialBinaryCode = codeFromA (const mempty)

-- | A CodeWord is a vector in the subspace C generated by the generator
--   of a linear code.
newtype Codeword (f :: *) (n :: Nat) = Codeword (Matrix f)
    deriving (Eq, Show)

instance (Num f, KnownNat n) => Monoid (Codeword f n) where
    mempty = Codeword $ zero 1 n'
        where n' = fromInteger $ natVal (Proxy :: Proxy n)
    mappend (Codeword x) (Codeword y) = Codeword $ x + y

-- | Convenience function to create codewords from a list
--   Will return Nothing if the list is not of the right size
codeword :: KnownNat n => LinearCode f n k -> [f] -> Maybe (Codeword f n)
codeword code cs =
    let n = codeLength code
     in if length cs == n
           then Just . Codeword $ fromList 1 n cs
           else Nothing

-- | Check multiplies the given codeword with the check matrix of the linear
--   code. If the result is the zero matrix, the given candidate is a valid
--   code word for the given code.
check :: Num f => LinearCode f n k -> Codeword f n -> Matrix f
check code (Codeword c) = checkMatrix code * transpose c

-- | Checks if the given candidate code word is a valid code word for the
--   given linear code. If not, the party check failed.
isCodeword :: forall f n k. (Field f, KnownNat n, KnownNat k) =>
    LinearCode f n k -> Codeword f n -> Bool
isCodeword code c =
    let n' = fromInteger $ natVal (Proxy :: Proxy n)
        k' = fromInteger $ natVal (Proxy :: Proxy k)
     in check code c == zero (n'-k') 1


